1. django-admin startproject robsite - создание проекта с его названием
2. python manage.py runserver - запуск сервера
3. python manage.py startapp dogs - создание нового приложения с его названием

--------------------------------------------
4. Динамические страницы:
- в файле dogs/urls.py прописываем путь на динамическую страницу по целому числу - /<int:cat_id>/ - без пробела
path('cats/<int: cats_id>/', views.categories)

- в файле dogs/views.py добавляем второй аргумент - cat_id и передаем его в return. При вводе числа в поисковой строке
будет открываться новая страница, соответствующая введенному числу

def categories(request, cat_id):
    return HttpResponse(f'<h1>Статьи по категориям</h1> <p>id: {cat_id}</p>')

- документация по типам маршрута (PATH CONVERTERS):
    https://docs.djangoproject.com/en/4.2/topics/http/urls/

- можно делать страницу не /<int:cat_id>/, по целому числу, а по любым символам - /<slug:cat_slug>/

- если конвертеров не хватает можно прописать путь через использование регулярных выражений - re_path. Импортируем
re_path прописываем путь (и не забываем прописать функцию archive в файле dogs/views.py:

re_path(r'^archive/(?P<year>[0-9]{4})/', views.archive)

- можно регулярные выражения преобразовывать через конвертер (специальный класс, который мы создаем, где описываем все
преобразования нашего регулярного выражения). Создаем новый файл для конвертеров dogs/converters.py, там прописываем
класс конвертера со всеми параметрами - FourDigitYearConverter. В файле dogs/urls.py импортируем регистратор
конвертеров: register_converter. Импортируем сам файл converters.py: from . import converters. После этого прописываем
строку регистрации конвертера с указанием названия: register_converter(converters.FourDigitYearConverter, 'year4').
Затем изменяем путь регулярного выражения на обычный путь: path('archive/<year4:year>/', views.archive). Сама функция в
файле dogs/views.py остается неизменной

--------------------------------------------
5. Существуют GET и POST запросы. Если мы добавим вывод GET запроса в нашу функцию:
def categories_by_slug(request, cat_slug):
    print(request.GET)
    return HttpResponse(f'<h1>Статьи по категориям</h1> <p>slug: {cat_slug}</p>')
А в браузере введем запрос: http://127.0.0.1:8000/cats/music/?name=Robert&age=2, то в терминале мы увидим словарь:
<QueryDict: {'name': ['Robert'], 'age': ['2']}>

--------------------------------------------
6. Мы можем в настройках проекта settings.py установить значение - DEBUG = False. Тогда нам нужно написать страницу,
которая будет отображаться если искомая страница не будет найдена. Действует вместо - Page not found 404. также мы
должны указать хост, который используем, чтобы можно было перейти на сайт - ALLOWED_HOSTS = ['127.0.0.1']

- мы можем обработать это исключение, и у нас будет выдаваться на страницу с ошибкой та надпись или тот материал,
которые мы зададим. Для этого в файле urls.py создаем специальный обработчик - handler404 = page_not_found

- далее прописываем функцию в файле dogs/views.py:
def page_not_found(request, exception):
    return HttpResponseNotFound('<h1>Страница не найдена =(</h1>')

- в файле urls.py импортируем созданную функцию для обработчика - from dogs.views import page_not_found

- мы можем импортировать Http404() и вызвать исключение в функции перехода на страницу. Пишем проверку и само
исключение, тогда нас перекинет на созданную нами ранее страницу, которая скажет, что такой страницы не существует:

def archive(request, year):
    if year > 2024:
        raise Http404()
    return HttpResponse(f'<h1>Архив по годам</h1> <p>{year}</p>')
